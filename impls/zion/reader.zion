import parser {
  all_of_input, parse_string, many, Span, ParseState, lift, char, text, const,
  sequence, Progress, OK, Fail, skip_while, span_concat, non_empty, many1,
  within_quotes, skip_trailing, until_one_of, choice, dot_star, digits,
  span_text, not_char}
import printer {pr_str}
import types {
  MalBool, MalNil, MalValue, MalInt, MalFloat, MalString, MalSymbol, MalList,
  MalVector, MalError, MalEOF, MalStop}

data Token {
  TSpecial(Char)
  TQuote(String)
  TQuasiAt
  TComment(String)
  TNonSpecial(String)
  TUnbalanced(String)
}

instance Str Token {
  fn str(t) => match t {
    TSpecial(ch)    => "TSpecial('${ch}')"
    TQuote(q)       => "TQuote(${q})"
    TQuasiAt        => "TQuasiAt"
    TComment(c)     => "TComment(${c})"
    TNonSpecial(ns) => "TNonSpecial(${ns})"
    TUnbalanced(c)  => "TUnbalanced(${c})"
  }
}

fn either_quotes(either) => match either {
  Left(unclosed) => TUnbalanced(unclosed)
  Right(spans) => TQuote(strconcat(spans))
}

let escaped_backslash = lift(const("\\"), text("\\\\", False))
let escaped_newline = lift(const("\n"), text("\\n", False))
let escaped_quote = lift(const("\""), text("\\\"", False))
let quoted_string = lift(either_quotes, within_quotes(
    '"',
    many(choice([
      escaped_newline,
      escaped_backslash,
      escaped_quote,
      lift(str, not_char('"')),
    ])))) as fn (ParseState) Progress ParseState Token

let comma_or_space = |x| => x == ',' or isspace(x)
fn skip_leading(ps ParseState) ParseState {
  return skip_while(ps, comma_or_space)
}

let skip_space_before = |parser| => |ps| => parser(skip_leading(ps))
fn skip_space_after(parser) {
  return |ps| => match parser(ps) {
    OK(ps, content) => OK(skip_leading(ps), content)
    Fail => Fail
  }
}

let comment_eol = lift(compose(TComment, compose(str, span_concat)), sequence([char(';'), dot_star]))
let quasi_at = lift(const(TQuasiAt), text("~@", False /*skip_leading_space*/))

fn special(ps ParseState) Progress ParseState Token {
  let ParseState(content, index) = ps
  if index < len(content) and content[index] in "[]{}()'`~^@" {
    return OK(ParseState(content, index + 1), TSpecial(content[index]))
  } else {
    return Fail
  }
}

let non_special = lift(.str.TNonSpecial, non_empty(until_one_of(" \r\n\t[]{}('\"`,;)")))
let tokenizer = all_of_input(
    skip_space_before(many1(
        skip_space_after(choice([
          quasi_at,
          special,
          quoted_string,
          comment_eol,
          non_special,
        ]))))) as fn (ps) Progress ParseState [Token]

newtype Reader = Reader([Token], var Int)

fn next(r) Maybe Token {
  let Reader(spans, var pos) = r
  if pos >= len(spans) {
    return Nothing
  } else {
    let cur_pos = pos
    pos += 1
    return Just(spans[cur_pos])
  }
}

fn peek(r) Maybe Token {
  let Reader(spans, var pos) = r
  if pos >= len(spans) {
    return Nothing
  } else {
    return Just(spans[pos])
  }
}

fn read_str(s String) Either MalStop MalValue {
  if tokenizer.parse_string(s) is Just(tokens) {
    return read_form_from_tokens(tokens)
  } else {
    return Left(MalError("Could not find any tokens."))
  }
}

fn read_form_from_tokens(spans) {
  assert(len(spans) > 0)
  return Reader(spans, new).read_form
}

fn is_token(reader, symbol) Bool { 
  if reader.peek is Just(TSpecial(s)) {
    if s == symbol {
      reader.next!
      return True
    }
  }
  return False
}

let is_rparen = |r| => r.is_token(')')
let is_rsquare = |r| => r.is_token(']')

fn read_quoted_list(reader, kind) => match reader.read_form {
  Right(form)   => Right(MalList([MalSymbol(kind), form]))
  error@Left(_) => error
}

fn read_form(reader) Either MalStop MalValue { 
  while match reader.next {
    Just(TSpecial('('))  => return reader.read_list(MalList, is_rparen)
    Just(TSpecial('['))  => return reader.read_list(MalVector, is_rsquare)
    Just(TComment(_))    => continue
    Just(TSpecial('\'')) => return reader.read_quoted_list("quote")
    Just(TSpecial('`'))  => return reader.read_quoted_list("quasiquote")
    Just(TSpecial('~'))  => return reader.read_quoted_list("unquote")
    Just(TQuasiAt)       => return reader.read_quoted_list("splice-unquote")
    Just(token)          => return token.read_atom
    Nothing              => return Left(MalError("end of input encountered"))
  }
  return Left(MalError("Not Reached"))
}

fn unescape_quoted_span(span Span) String {
  let s = str(span)
  assert(s[0] == '"')
  assert(s[len(s)-1] == '"')
  return s[1:len(s)-1].replace("\\\\", "\\").replace("\\\"", "\"")
}

let mal_atom_parser = all_of_input(choice([
  lift(|x| => MalInt(int(str(x))), digits),
  lift(const(MalNil), text("nil", False)),
  lift(const(MalBool(True)), text("true", False)),
  lift(const(MalBool(False)), text("false", False)),
  lift(compose(MalString, |s [Span]| => str(s[1])), sequence([char('"'), dot_star])),
  lift(|x| => MalSymbol(str(x)), until_one_of("")),
]))

fn read_atom(token Token) Either MalStop MalValue {
  return match token {
    TSpecial(ch) => Right(MalSymbol(str(ch)))
    TQuote(s)    => Right(MalString(s))
    TQuasiAt     => Right(MalSymbol("~@"))
    TComment(c)  => Left(MalError("Unexpected comment ${c}"))
    TNonSpecial(ident) => Right(MalSymbol(ident))
    TUnbalanced(u) => Left(MalError("unbalanced token encountered: ${u}"))
  }
}

fn read_list(reader, ctor, is_closing_symbol) Either MalStop MalValue {
  let result = []
  while not is_closing_symbol(reader) {
    match reader.read_form {
      Left(MalEOF) {
        return Left(MalError("Premature end of input while reading list."))
      }
      l@Left(_) => return l
      Right(value) => result.append(value)
    }
  }
  return Right(ctor(result))
}

fn main() {
  print("\\\\")
  print(compose(pr_str, compose(MalString, str)).fmap(quoted_string.parse_string("\"h\\\"ey\"")))
  print(read_str("(hey this is 900 'cool nil \"this \\\"is\\\" working\" true false)"))
}
