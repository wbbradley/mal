import env {Env}
import types {
  to_mal_value, MalList, MalError, MalStop, MalValue, MalEOF, MalInt, MalFloat,
  MalString, MalBool, MalNil, MalDict, MalVector, MalSymbol, MalLambda, error}
import printer {pr_str}

let str_combine = |x, y| => "${x}${y}".MalString.Right

fn mal_add(a, b) => match a {
  MalInt(x) => match b {
    MalInt(y)       => Right(MalInt(x + y))
    MalFloat(y)     => Right(MalFloat(float(x) + y))
    MalString(y)    => str_combine(x, y)
  } else => "+ is not defined for ${a} and ${b}".error
  MalFloat(x) => match b {
    MalInt(y)     => Right(MalFloat(x + float(y)))
    MalFloat(y)   => Right(MalFloat(x + y))
    MalString(y)  => str_combine(x, y)
  } else => "+ is not defined for ${a} and ${b}".error
  MalString(x) => match b {
    MalString(y) => str_combine(x, y)
    MalInt(y)    => str_combine(x, y)
    MalFloat(y)  => str_combine(x, y)
  } else => "+ is not defined for ${a} and ${b}".error
} else => "+ is not defined for ${a} and ${b}".error

fn mal_sub(a, b) => match (a, b) {
  (MalInt(x), MalInt(y))       => Right(MalInt(x - y))
  (MalInt(x), MalFloat(y))     => Right(MalFloat(float(x) - y))
  (MalFloat(x), MalInt(y))     => Right(MalFloat(x - float(y)))
  (MalFloat(x), MalFloat(y))   => Right(MalFloat(x - y))
} else => "- is not defined for ${a} and ${b}".error

fn mal_div(a, b) => match (a, b) {
  (MalInt(x), MalInt(y))       => y != 0 ? Right(MalInt(x / y)) : "division by zero error".error
  (MalInt(x), MalFloat(y))     => Right(MalFloat(float(x) / y))
  (MalFloat(x), MalInt(y))     => y != 0 ? Right(MalFloat(x / float(y))) : "division by zero error".error
  (MalFloat(x), MalFloat(y))   => Right(MalFloat(x / y))
} else => "/ is not defined for ${a} and ${b}".error

fn mal_mul(a, b) => match (a, b) {
  (MalInt(x), MalInt(y))       => Right(MalInt(x * y))
  (MalInt(x), MalFloat(y))     => Right(MalFloat(float(x) * y))
  (MalFloat(x), MalInt(y))     => Right(MalFloat(x * float(y)))
  (MalFloat(x), MalFloat(y))   => Right(MalFloat(x * y))
} else => "* is not defined for ${a} and ${b}".error

fn mal_prn(a) {
  print(a.pr_str(True))
  return MalNil.Right
}

fn make_builtin_2(name, func) => |args| {
  if len(args) != 2 {
    return "incorrect number of args passed to ${name}. expected 2".error
  }
  return func(args[0], args[1])
}

fn make_builtin_1(name, func) => |args| {
  if len(args) != 1 {
    return "incorrect number of args passed to ${name}. expected 1".error
  }
  return func(args[0])
}

let booly = |x| => x.MalBool.Right

let mal_is_list = make_builtin_1("list?", |x| => booly(match x {
  MalList(_) => True
} else => False))

let mal_is_empty = make_builtin_1("empty?", |x| => booly(match x {
  MalList(l) => len(l) == 0
  MalVector(l) => len(l) == 0
} else => True))

let mal_count = make_builtin_1("count", |x| => match x {
  MalList(xs) => Right(MalInt(xs.len))
  MalVector(xs) => Right(MalInt(xs.len))
} else => zero)

let mal_eq = make_builtin_2("=", |x, y| => booly(x == y))

let mal_not = make_builtin_1("not", |x| => booly(match x {
  MalNil => True
  MalBool(value) => not value
  _ => False
}))


let zero = Right(MalInt(0))

fn mal_binary_op(binary_op_name, int_binary_op, float_binary_op, string_binary_op) => |a, b| => match a {
  MalInt(x) => match b {
    MalInt(y)   => int_binary_op(x, y).to_mal_value.Right
    MalFloat(y) => float_binary_op(float(x), y).to_mal_value.Right
  } else => "${a} ${binary_op_name} ${b} is undefined".error
  MalFloat(x) => match b {
    MalInt(y)   => float_binary_op(x, float(y)).to_mal_value.Right
    MalFloat(y) => float_binary_op(x, y).to_mal_value.Right
  } else => "${binary_op_name} is not defined for ${a} and ${b}".error
  MalString(x) => match b {
    MalString(y) => string_binary_op(x, y).to_mal_value.Right
  } else => "${binary_op_name} is not defined for ${a} and ${b}".error
} else => "${binary_op_name} is not defined for ${a} and ${b}".error

fn mal_pr_str(args) {

}

let core_fns = {
  "+": make_builtin_2("+", mal_add),
  "-": make_builtin_2("-", mal_sub),
  "*": make_builtin_2("*", mal_mul),
  "/": make_builtin_2("/", mal_div),
  ">": make_builtin_2(">", mal_binary_op(">", (>), (>), (>))),
  "<": make_builtin_2("<", mal_binary_op("<", (<), (<), (<))),
  ">=": make_builtin_2(">=", mal_binary_op(">=", (>=), (>=), (>=))),
  "<=": make_builtin_2("<=", mal_binary_op("<=", (<=), (<=), (<=))),
  "=": mal_eq,
  "not": mal_not,
  "prn": make_builtin_1("prn", mal_prn),
  # "pr-str": mal_pr_str,
  "list": .MalList.Right,
  "list?": mal_is_list,
  "empty?": mal_is_empty,
  "count": mal_count,
}

let ns = {k: MalLambda(v) for (k, v) in core_fns}
